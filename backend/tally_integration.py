# -*- coding: utf-8 -*-
"""
Tally Software Integration Module
Supports data exchange between FinSight and Tally ERP/TallyPrime

Features:
1. Export processed documents to Tally XML format (for import into Tally)
2. Convert bank transactions to Tally vouchers
3. Convert invoices/Purchase Orders to Tally vouchers
4. Generate Tally-compatible XML files
"""

import xml.etree.ElementTree as ET
from xml.dom import minidom
from datetime import datetime
from typing import Dict, List, Optional, Any
import json


class TallyXMLGenerator:
    """Generate Tally-compatible XML files for importing data"""
    
    def __init__(self, company_name: str = "FinSight Company"):
        self.company_name = company_name
        self.namespace = "http://www.tallysolutions.com/XML/Integration"
    
    def _create_envelope(self):
        """Create Tally XML envelope structure
        
        Returns:
            tuple: (envelope_element, tally_message_element)
        """
        envelope = ET.Element("ENVELOPE")
        header = ET.SubElement(envelope, "HEADER")
        version = ET.SubElement(header, "VERSION")
        version.text = "1"
        tally_request = ET.SubElement(header, "TALLYREQUEST")
        tally_request.text = "Import"
        body = ET.SubElement(envelope, "BODY")
        import_data = ET.SubElement(body, "IMPORTDATA")
        request_desc = ET.SubElement(import_data, "REQUESTDESC")
        report_name = ET.SubElement(request_desc, "REPORTNAME")
        report_name.text = "Vouchers"
        static_variables = ET.SubElement(request_desc, "STATICVARIABLES")
        sv_current_company = ET.SubElement(static_variables, "SVCURRENTCOMPANY")
        sv_current_company.text = self.company_name
        request_data = ET.SubElement(import_data, "REQUESTDATA")
        tally_message = ET.SubElement(request_data, "TALLYMESSAGE")
        return envelope, tally_message
    
    def _format_date(self, date_str: str) -> str:
        """Convert date to Tally format (YYYYMMDD)"""
        try:
            # Try various date formats
            for fmt in ["%Y-%m-%d", "%d-%m-%Y", "%d/%m/%Y", "%Y/%m/%d"]:
                try:
                    dt = datetime.strptime(date_str, fmt)
                    return dt.strftime("%Y%m%d")
                except ValueError:
                    continue
            return datetime.now().strftime("%Y%m%d")
        except:
            return datetime.now().strftime("%Y%m%d")
    
    def create_payment_voucher(self, 
                               voucher_date: str,
                               party_name: str,
                               amount: float,
                               narration: str = "",
                               payment_mode: str = "Cash",
                               ledger_name: str = "Cash") -> ET.Element:
        """
        Create a Payment Voucher for Tally
        
        Args:
            voucher_date: Date in YYYY-MM-DD format
            party_name: Name of the party being paid
            amount: Payment amount
            narration: Description/notes
            payment_mode: Payment mode (Cash, Bank, Cheque, etc.)
            ledger_name: Ledger account name (default: Cash)
        """
        voucher = ET.Element("VOUCHER")
        voucher.set("VCHTYPE", "Payment")
        
        # Voucher date
        date = ET.SubElement(voucher, "DATE")
        date.text = self._format_date(voucher_date)
        
        # Voucher number (auto-generated by Tally if not provided)
        # vouchernumber = ET.SubElement(voucher, "VOUCHERNUMBER")
        # vouchernumber.text = ""
        
        # Party ledger (Cr)
        ledger = ET.SubElement(voucher, "PARTYLEDGERNAME")
        ledger.text = party_name
        
        # Narration
        if narration:
            narration_elem = ET.SubElement(voucher, "NARRATION")
            narration_elem.text = narration
        
        # Entry type
        entry_type = ET.SubElement(voucher, "ENTRYTYPE")
        entry_type.text = "Payment"
        
        # All ledger entries
        all_ledger_entries = ET.SubElement(voucher, "ALLLEDGERENTRIES.LIST")
        
        # Payment ledger (Dr) - Cash/Bank
        ledger_entry_dr = ET.SubElement(all_ledger_entries, "LEDGERNAME")
        ledger_entry_dr.text = ledger_name
        is_deemed_positive_dr = ET.SubElement(all_ledger_entries, "ISDEEMEDPOSITIVE")
        is_deemed_positive_dr.text = "Yes"  # Debit
        amount_dr = ET.SubElement(all_ledger_entries, "AMOUNT")
        amount_dr.text = f"{-amount:.2f}"  # Negative for debit
        
        # Party ledger (Cr)
        all_ledger_entries2 = ET.SubElement(voucher, "ALLLEDGERENTRIES.LIST")
        ledger_entry_cr = ET.SubElement(all_ledger_entries2, "LEDGERNAME")
        ledger_entry_cr.text = party_name
        is_deemed_positive_cr = ET.SubElement(all_ledger_entries2, "ISDEEMEDPOSITIVE")
        is_deemed_positive_cr.text = "No"  # Credit
        amount_cr = ET.SubElement(all_ledger_entries2, "AMOUNT")
        amount_cr.text = f"{amount:.2f}"  # Positive for credit
        
        return voucher
    
    def create_receipt_voucher(self,
                               voucher_date: str,
                               party_name: str,
                               amount: float,
                               narration: str = "",
                               receipt_mode: str = "Cash",
                               ledger_name: str = "Cash") -> ET.Element:
        """
        Create a Receipt Voucher for Tally
        
        Args:
            voucher_date: Date in YYYY-MM-DD format
            party_name: Name of the party receiving payment
            amount: Receipt amount
            narration: Description/notes
            receipt_mode: Receipt mode (Cash, Bank, Cheque, etc.)
            ledger_name: Ledger account name (default: Cash)
        """
        voucher = ET.Element("VOUCHER")
        voucher.set("VCHTYPE", "Receipt")
        
        date = ET.SubElement(voucher, "DATE")
        date.text = self._format_date(voucher_date)
        
        party_ledger = ET.SubElement(voucher, "PARTYLEDGERNAME")
        party_ledger.text = party_name
        
        if narration:
            narration_elem = ET.SubElement(voucher, "NARRATION")
            narration_elem.text = narration
        
        entry_type = ET.SubElement(voucher, "ENTRYTYPE")
        entry_type.text = "Receipt"
        
        # Receipt ledger (Dr) - Cash/Bank
        all_ledger_entries = ET.SubElement(voucher, "ALLLEDGERENTRIES.LIST")
        ledger_entry_dr = ET.SubElement(all_ledger_entries, "LEDGERNAME")
        ledger_entry_dr.text = ledger_name
        is_deemed_positive_dr = ET.SubElement(all_ledger_entries, "ISDEEMEDPOSITIVE")
        is_deemed_positive_dr.text = "Yes"  # Debit
        amount_dr = ET.SubElement(all_ledger_entries, "AMOUNT")
        amount_dr.text = f"{-amount:.2f}"  # Negative for debit
        
        # Party ledger (Cr)
        all_ledger_entries2 = ET.SubElement(voucher, "ALLLEDGERENTRIES.LIST")
        ledger_entry_cr = ET.SubElement(all_ledger_entries2, "LEDGERNAME")
        ledger_entry_cr.text = party_name
        is_deemed_positive_cr = ET.SubElement(all_ledger_entries2, "ISDEEMEDPOSITIVE")
        is_deemed_positive_cr.text = "No"  # Credit
        amount_cr = ET.SubElement(all_ledger_entries2, "AMOUNT")
        amount_cr.text = f"{amount:.2f}"  # Positive for credit
        
        return voucher
    
    def create_sales_voucher(self,
                            voucher_date: str,
                            party_name: str,
                            items: List[Dict],
                            narration: str = "",
                            sales_ledger: str = "Sales Account") -> ET.Element:
        """
        Create a Sales Voucher for Tally
        
        Args:
            voucher_date: Date in YYYY-MM-DD format
            party_name: Customer name
            items: List of items with keys: name, quantity, rate, amount
            narration: Description/notes
            sales_ledger: Sales ledger account name
        """
        voucher = ET.Element("VOUCHER")
        voucher.set("VCHTYPE", "Sales")
        
        date = ET.SubElement(voucher, "DATE")
        date.text = self._format_date(voucher_date)
        
        party_ledger = ET.SubElement(voucher, "PARTYLEDGERNAME")
        party_ledger.text = party_name
        
        if narration:
            narration_elem = ET.SubElement(voucher, "NARRATION")
            narration_elem.text = narration
        
        entry_type = ET.SubElement(voucher, "ENTRYTYPE")
        entry_type.text = "Sales"
        
        total_amount = 0
        
        # Add items as inventory entries
        for item in items:
            item_name = item.get("name", item.get("description", "Item"))
            quantity = float(item.get("quantity", 1))
            rate = float(item.get("rate", item.get("amount", 0)))
            amount = float(item.get("amount", quantity * rate))
            total_amount += amount
            
            # Inventory entry
            inventory_entries = ET.SubElement(voucher, "ALLINVENTORYENTRIES.LIST")
            stock_item_name = ET.SubElement(inventory_entries, "STOCKITEMNAME")
            stock_item_name.text = item_name
            is_deemed_positive = ET.SubElement(inventory_entries, "ISDEEMEDPOSITIVE")
            is_deemed_positive.text = "No"  # Outward
            rate_elem = ET.SubElement(inventory_entries, "RATE")
            rate_elem.text = f"{rate:.2f}"
            amount_elem = ET.SubElement(inventory_entries, "AMOUNT")
            amount_elem.text = f"{-amount:.2f}"
            actual_qty = ET.SubElement(inventory_entries, "ACTUALQTY")
            actual_qty.text = f"{quantity:.2f}"
            billed_qty = ET.SubElement(inventory_entries, "BILLEDQTY")
            billed_qty.text = f"{quantity:.2f}"
        
        # Sales ledger (Cr)
        all_ledger_entries = ET.SubElement(voucher, "ALLLEDGERENTRIES.LIST")
        ledger_entry_cr = ET.SubElement(all_ledger_entries, "LEDGERNAME")
        ledger_entry_cr.text = sales_ledger
        is_deemed_positive_cr = ET.SubElement(all_ledger_entries, "ISDEEMEDPOSITIVE")
        is_deemed_positive_cr.text = "No"  # Credit
        amount_cr = ET.SubElement(all_ledger_entries, "AMOUNT")
        amount_cr.text = f"{total_amount:.2f}"
        
        # Party ledger (Dr)
        all_ledger_entries2 = ET.SubElement(voucher, "ALLLEDGERENTRIES.LIST")
        ledger_entry_dr = ET.SubElement(all_ledger_entries2, "LEDGERNAME")
        ledger_entry_dr.text = party_name
        is_deemed_positive_dr = ET.SubElement(all_ledger_entries2, "ISDEEMEDPOSITIVE")
        is_deemed_positive_dr.text = "Yes"  # Debit
        amount_dr = ET.SubElement(all_ledger_entries2, "AMOUNT")
        amount_dr.text = f"{-total_amount:.2f}"
        
        return voucher
    
    def create_journal_voucher(self,
                              voucher_date: str,
                              entries: List[Dict],
                              narration: str = "") -> ET.Element:
        """
        Create a Journal Voucher for Tally
        
        Args:
            voucher_date: Date in YYYY-MM-DD format
            entries: List of ledger entries with keys: ledger_name, amount, is_debit
            narration: Description/notes
        """
        voucher = ET.Element("VOUCHER")
        voucher.set("VCHTYPE", "Journal")
        
        date = ET.SubElement(voucher, "DATE")
        date.text = self._format_date(voucher_date)
        
        if narration:
            narration_elem = ET.SubElement(voucher, "NARRATION")
            narration_elem.text = narration
        
        entry_type = ET.SubElement(voucher, "ENTRYTYPE")
        entry_type.text = "Journal"
        
        for entry in entries:
            ledger_name = entry.get("ledger_name", "")
            amount = float(entry.get("amount", 0))
            is_debit = entry.get("is_debit", True)
            
            all_ledger_entries = ET.SubElement(voucher, "ALLLEDGERENTRIES.LIST")
            ledger_entry = ET.SubElement(all_ledger_entries, "LEDGERNAME")
            ledger_entry.text = ledger_name
            is_deemed_positive = ET.SubElement(all_ledger_entries, "ISDEEMEDPOSITIVE")
            is_deemed_positive.text = "Yes" if is_debit else "No"
            amount_elem = ET.SubElement(all_ledger_entries, "AMOUNT")
            amount_elem.text = f"{-amount:.2f}" if is_debit else f"{amount:.2f}"
        
        return voucher
    
    def generate_xml(self, vouchers: List[ET.Element]) -> str:
        """Generate complete Tally XML string from vouchers"""
        envelope, tally_message = self._create_envelope()
        
        for voucher in vouchers:
            tally_message.append(voucher)
        
        # Convert to XML string with proper formatting
        rough_string = ET.tostring(envelope, encoding='unicode')
        reparsed = minidom.parseString(rough_string)
        return reparsed.toprettyxml(indent="  ")
    
    def convert_bank_statement_to_vouchers(self, bank_statement_data: Dict) -> List[ET.Element]:
        """
        Convert bank statement transactions to Tally vouchers
        
        Args:
            bank_statement_data: Processed bank statement data from extract_bank_statement_structured
        """
        vouchers = []
        transactions = bank_statement_data.get("transactions", [])
        
        for txn in transactions:
            date = txn.get("date", datetime.now().strftime("%Y-%m-%d"))
            description = txn.get("description", "")
            amount = float(txn.get("amount", 0) or txn.get("credit", 0) or txn.get("debit", 0) or 0)
            txn_type = txn.get("type", "").lower()
            
            if not amount or amount == 0:
                continue
            
            party_name = description[:50]  # Limit length for Tally
            
            if txn_type == "credit" or txn.get("credit"):
                # Credit = Money received = Receipt voucher
                voucher = self.create_receipt_voucher(
                    voucher_date=date,
                    party_name=party_name or "Bank Deposit",
                    amount=amount,
                    narration=f"Bank Statement: {description}",
                    receipt_mode="Bank",
                    ledger_name="Bank Account"
                )
            else:
                # Debit = Money paid = Payment voucher
                voucher = self.create_payment_voucher(
                    voucher_date=date,
                    party_name=party_name or "Bank Withdrawal",
                    amount=amount,
                    narration=f"Bank Statement: {description}",
                    payment_mode="Bank",
                    ledger_name="Bank Account"
                )
            
            vouchers.append(voucher)
        
        return vouchers
    
    def convert_invoice_to_voucher(self, invoice_data: Dict) -> ET.Element:
        """Convert invoice data to Tally Sales Voucher"""
        invoice_date = invoice_data.get("invoice_date", invoice_data.get("date", datetime.now().strftime("%Y-%m-%d")))
        buyer = invoice_data.get("buyer", {})
        party_name = buyer.get("name", "Customer")
        items = invoice_data.get("items", invoice_data.get("line_items", []))
        narration = f"Invoice: {invoice_data.get('invoice_number', '')}"
        
        return self.create_sales_voucher(
            voucher_date=invoice_date,
            party_name=party_name,
            items=items,
            narration=narration
        )
    
    def convert_trial_balance_to_vouchers(self, trial_balance_data: Dict) -> List[ET.Element]:
        """
        Convert trial balance account balances to Tally Opening Balance/Journal vouchers
        
        Args:
            trial_balance_data: Processed trial balance data from extract_trial_balance
        """
        vouchers = []
        balances = trial_balance_data.get("balances", [])
        period = trial_balance_data.get("period", "")
        entity_name = trial_balance_data.get("entity_name", "Company")
        prepared_date = trial_balance_data.get("prepared_date", datetime.now().strftime("%Y-%m-%d"))
        
        if not balances:
            return vouchers
        
        # Group accounts by date if available, otherwise use prepared_date
        # Create journal vouchers for account balances
        # Each voucher contains debit and credit entries that balance
        
        # Group accounts by date (if transactions have dates, otherwise use one voucher for all)
        account_entries = []
        for bal in balances:
            account_name = bal.get("account_name", "")
            account_type = bal.get("account_type", "")
            debit = float(bal.get("debit", 0) or 0)
            credit = float(bal.get("credit", 0) or 0)
            balance = float(bal.get("balance", 0) or 0)
            
            # Use balance if available, otherwise use debit/credit
            if balance != 0:
                if balance > 0:
                    # Positive balance is typically a debit (asset/expense)
                    account_entries.append({
                        "ledger_name": account_name,
                        "amount": abs(balance),
                        "is_debit": True
                    })
                else:
                    # Negative balance is typically a credit (liability/income/equity)
                    account_entries.append({
                        "ledger_name": account_name,
                        "amount": abs(balance),
                        "is_debit": False
                    })
            elif debit > 0:
                account_entries.append({
                    "ledger_name": account_name,
                    "amount": debit,
                    "is_debit": True
                })
            elif credit > 0:
                account_entries.append({
                    "ledger_name": account_name,
                    "amount": credit,
                    "is_debit": False
                })
        
        # Create a journal voucher with all account entries
        # Tally requires balanced entries, so we need to ensure debits = credits
        total_debits = sum(entry["amount"] for entry in account_entries if entry["is_debit"])
        total_credits = sum(entry["amount"] for entry in account_entries if not entry["is_debit"])
        
        # Adjust if unbalanced (add to retained earnings or suspense account)
        difference = total_debits - total_credits
        if abs(difference) > 0.01:  # Allow small rounding differences
            if difference > 0:
                # More debits, add credit entry
                account_entries.append({
                    "ledger_name": "Retained Earnings" if "equity" in entity_name.lower() else "Suspense Account",
                    "amount": difference,
                    "is_debit": False
                })
            else:
                # More credits, add debit entry
                account_entries.append({
                    "ledger_name": "Retained Earnings" if "equity" in entity_name.lower() else "Suspense Account",
                    "amount": abs(difference),
                    "is_debit": True
                })
        
        # Create journal voucher with all entries
        if account_entries:
            narration = f"Trial Balance - {period}" if period else "Trial Balance Opening Balances"
            voucher = self.create_journal_voucher(
                voucher_date=prepared_date,
                entries=account_entries,
                narration=narration
            )
            vouchers.append(voucher)
        
        return vouchers


def export_to_tally_xml(data: Dict, document_type: str, company_name: str = "FinSight Company") -> str:
    """
    Main function to export processed document data to Tally XML format
    
    Args:
        data: Processed document data
        document_type: Type of document (bank_statement, invoice, etc.)
        company_name: Tally company name
    
    Returns:
        XML string ready for import into Tally
    """
    generator = TallyXMLGenerator(company_name=company_name)
    vouchers = []
    
    if document_type == "bank_statement":
        vouchers = generator.convert_bank_statement_to_vouchers(data)
    elif document_type == "invoice":
        voucher = generator.convert_invoice_to_voucher(data)
        vouchers = [voucher]
    elif document_type == "trial_balance":
        vouchers = generator.convert_trial_balance_to_vouchers(data)
    # Add more document types as needed
    
    if not vouchers:
        raise ValueError(f"No vouchers generated for document type: {document_type}")
    
    return generator.generate_xml(vouchers)

